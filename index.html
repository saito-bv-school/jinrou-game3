<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Werewolf: The Grimoire (Custom)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* ã‚´ã‚·ãƒƒã‚¯ãƒ»ã‚¿ãƒ­ãƒƒãƒˆ ãƒ‘ãƒ¬ãƒƒãƒˆ */
            --bg-paper: #e3d8c4;
            --bg-dark: #1a1510;
            --bg-dark-transparent: rgba(20, 16, 12, 0.95);
            --accent-gold: #c5a059;
            --accent-blood: #8a1c1c;
            --text-main: #2c241b;
            --text-light: #e3d8c4;

            /* å½¹è·ã‚«ãƒ©ãƒ¼ */
            --role-wolf: #b71c1c;
            --role-seer: #7b1fa2;
            --role-guard: #00695c;
            --role-madman: #e65100;
            --role-medium: #7b1fa2;
            --role-fox: #fbc02d;
            --role-fanatic: #ef6c00;
            --role-immoral: #5d4037;
            --role-cat: #ad1457;
            --role-baker: #795548;

            --nav-height: 70px;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-dark);
            background-image:
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E"),
                radial-gradient(circle at center, #2a221b 0%, #000000 100%);
            color: var(--text-light);
            font-family: 'Shippori Mincho', serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        h1,
        h2,
        h3,
        h4 {
            margin: 0;
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        button {
            border: 1px solid var(--accent-gold);
            background: linear-gradient(135deg, #2c241b 0%, #1a1510 100%);
            color: var(--accent-gold);
            font-family: 'Shippori Mincho', serif;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            width: 100%;
            font-size: 1em;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            filter: grayscale(100%);
            cursor: not-allowed;
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-blood) 0%, #4a0f0f 100%);
            color: white;
            border-color: #ff5252;
        }

        button.icon-btn {
            width: auto;
            padding: 5px 10px;
            background: transparent;
            border: none;
            box-shadow: none;
            font-size: 1.5em;
        }

        button.sm-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        button.gm-login-btn {
            margin-top: 20px;
            background: transparent;
            border: 1px dashed var(--text-main);
            color: var(--text-main);
            font-size: 0.8em;
            padding: 8px;
            cursor: pointer;
        }

        button.gm-login-btn:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        input,
        select {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--accent-gold);
            color: var(--text-light);
            font-family: 'Shippori Mincho', serif;
            border-radius: 4px;
        }

        input[type="password"] {
            background: var(--bg-paper);
            color: var(--text-main);
            border: 1px solid var(--text-main);
            font-family: sans-serif;
        }

        option {
            background: var(--bg-dark);
            color: var(--text-light);
        }

        /* --- Layout --- */
        header {
            height: 60px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: var(--bg-dark-transparent);
            border-bottom: 1px solid var(--accent-gold);
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .phase-indicator {
            font-size: 1.2em;
            color: var(--accent-gold);
            text-shadow: 0 0 5px rgba(197, 160, 89, 0.3);
        }

        .timer {
            font-family: monospace;
            font-size: 1.2em;
            color: var(--accent-blood);
            margin-left: 10px;
        }

        main {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 20px;
            position: relative;
            -webkit-overflow-scrolling: touch;
        }

        .night-mode main {
            background: rgba(0, 0, 0, 0.6);
        }

        nav {
            height: var(--nav-height);
            flex-shrink: 0;
            background: #0f0c0a;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-top: 1px solid var(--accent-gold);
            z-index: 20;
        }

        .nav-item {
            display: flex;
            flex: 1;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.7em;
            cursor: pointer;
            width: 100%;
            height: 100%;
            transition: color 0.3s;
            position: relative;
        }

        .nav-item.active {
            color: var(--accent-gold);
            background: rgba(197, 160, 89, 0.05);
        }

        .nav-icon {
            font-size: 1.5em;
            margin-bottom: 4px;
        }

        .badge {
            background: var(--accent-blood);
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 0.8em;
            position: absolute;
            top: 5px;
            right: 20%;
        }

        /* --- Components --- */
        .config-panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #444;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .player-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: linear-gradient(to right, #2a221b, transparent);
            border-left: 3px solid var(--accent-gold);
            border-bottom: 1px solid #333;
        }

        .player-list-item.dead {
            opacity: 0.4;
            text-decoration: line-through;
            border-left-color: #555;
        }

        .tarot-card {
            background-color: var(--bg-paper);
            color: var(--text-main);
            border: 4px double var(--text-main);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .tarot-card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='2' cy='2' r='1' fill='%232c241b' opacity='0.1'/%3E%3C/svg%3E");
            opacity: 0.3;
            pointer-events: none;
        }

        .tarot-title {
            font-size: 1.5em;
            border-bottom: 2px solid var(--text-main);
            margin-bottom: 10px;
            padding-bottom: 5px;
        }

        .tarot-desc {
            font-size: 0.9em;
            line-height: 1.6;
            font-style: italic;
        }

        .spotlight-target {
            transition: all 0.5s ease;
            opacity: 0.6;
            filter: grayscale(80%);
            margin-bottom: 8px;
        }

        .spotlight-target.selected {
            opacity: 1;
            filter: grayscale(0%);
            transform: scale(1.02);
            z-index: 5;
        }

        .target-btn {
            width: 100%;
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            color: #ccc;
        }

        .target-btn.active {
            background: var(--accent-blood);
            border-color: red;
            color: white;
            box-shadow: 0 0 15px var(--accent-blood);
        }

        .story-card {
            background: rgba(20, 16, 12, 0.8);
            border: 1px solid var(--accent-gold);
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent-gold);
            animation: slideIn 0.5s ease;
        }

        .story-card.death {
            border-left-color: var(--accent-blood);
            background: rgba(50, 0, 0, 0.3);
        }

        .story-time {
            font-size: 0.7em;
            color: var(--accent-gold);
            display: block;
            margin-bottom: 5px;
            opacity: 0.7;
        }

        .story-text {
            font-size: 1em;
            line-height: 1.5;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Toggle Switch */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .toggle-label {
            font-size: 0.9em;
            color: var(--text-light);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent-gold);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-paper);
            color: var(--text-main);
            padding: 20px;
            border: 4px double var(--bg-dark);
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            padding: 0;
            width: auto;
            color: var(--text-main);
            box-shadow: none;
            cursor: pointer;
        }

        .host-badge {
            color: var(--accent-gold);
            font-size: 0.8em;
            border: 1px solid var(--accent-gold);
            padding: 1px 4px;
            border-radius: 4px;
            margin-left: 5px;
        }

        .vis-badge {
            font-size: 0.8em;
            border: 1px solid #666;
            padding: 1px 4px;
            border-radius: 4px;
            margin-left: 5px;
            background: #333;
            color: #fff;
        }

        .action-result {
            font-size: 0.8em;
            padding: 1px 5px;
            border-radius: 4px;
            margin-left: 5px;
            background: #333;
            border: 1px solid #555;
            white-space: nowrap;
            display: inline-block;
            margin-top: 2px;
        }

        .result-safe {
            color: #69f0ae;
            border-color: #69f0ae;
        }

        .result-danger {
            color: #ff5252;
            border-color: #ff5252;
        }

        .result-fox {
            color: var(--role-fox);
            border-color: var(--role-fox);
        }

        .error-box {
            position: fixed;
            top: 70px;
            left: 10px;
            right: 10px;
            background: rgba(50, 0, 0, 0.9);
            padding: 10px;
            border: 1px solid red;
            z-index: 999;
            color: #ffaaaa;
        }

        .nav-area {
            display: flex;
            flex: 1;
            justify-content: space-around;
            /* å‡ç­‰é…ç½® */
        }
    </style>

    <script type="importmap">
    {
      "imports": {
        "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
        "firebase/app": "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js",
        "firebase/database": "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js"
      }
    }
    </script>
</head>

<body>

    <div id="app" :class="{ 'night-mode': state.phase === 'NIGHT' }">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header>
            <div class="phase-indicator">
                <span v-if="state.phase === 'LOBBY'">å¾…åˆå®¤</span>
                <span v-else-if="state.phase === 'NIGHT'">ğŸŒ™ ç¬¬{{state.turn_count}}å¤œ</span>
                <span v-else-if="state.phase === 'DAY'">â˜€ï¸ {{state.turn_count}}æ—¥ç›®</span>
                <span v-else-if="state.phase === 'VOTE'">âš–ï¸ å¯©åˆ¤</span>
                <span v-else>çµ‚å¹•</span>
            </div>
            <div class="nav-area">
                <div class="nav-item" :class="{ active: activeTab === 'players' }" @click="activeTab = 'players'">
                    <span class="nav-icon">â™Ÿ</span><span>é‹å‘½</span>
                </div>
                <div class="nav-item" :class="{ active: activeTab === 'action' }" @click="activeTab = 'action'">
                    <span class="nav-icon">ğŸ”®</span><span>å„€å¼</span>
                    <span
                        v-if="!hasActionDone && !state.winner_team && myPlayer?.is_alive && (state.phase === 'VOTE' || state.phase === 'NIGHT')"
                        class="badge">!</span>
                </div>
                <div class="nav-item" :class="{ active: activeTab === 'logs' }" @click="activeTab = 'logs'">
                    <span class="nav-icon">ğŸ“œ</span><span>å¹´ä»£è¨˜</span>
                </div>
                <!-- GMç”¨ã‚¿ãƒ–: ãƒ›ã‚¹ãƒˆã®ã¿è¡¨ç¤º -->
                <div v-if="isHost" class="nav-item" :class="{ active: activeTab === 'gm' }" @click="activeTab = 'gm'">
                    <span class="nav-icon" style="color:var(--accent-gold);">ğŸ‘‘</span><span
                        style="color:var(--accent-gold);">æ”¯é…</span>
                </div>
                <div style="display:flex; align-items:center;">
                    <button class="icon-btn" @click="showRoleList = true">ğŸ“–</button>
                    <div class="timer" v-if="state.timer_end_at > 0">{{ timeLeft }}</div>
                </div>
            </div>
        </header>

        <!-- å½¹è·ä¸€è¦§ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div v-if="showRoleList" class="modal-overlay" @click.self="showRoleList = false">
            <div class="modal-content">
                <button class="close-btn" @click="showRoleList = false">Ã—</button>
                <h3
                    style="color:var(--text-main); border-bottom:1px solid var(--accent-gold); margin-bottom:15px; padding-bottom:5px;">
                    ç¦æ–­ã®çŸ¥è­˜</h3>
                <div v-for="(def, key) in roleDefinitions" :key="key"
                    style="margin-bottom:15px; border-bottom:1px dashed #ccc; padding-bottom:10px;">
                    <div style="font-weight:bold; color:var(--text-main); font-size:1.1em;">
                        {{ def.label }} <span :style="{color: getRoleColor(key), fontSize:'0.7em'}">({{ def.team
                            }})</span>
                    </div>
                    <div style="font-size:0.9em; color:#444; margin-top:5px; line-height:1.4;">{{ def.desc }}</div>
                </div>
                <!-- GMãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ -->
                <div style="margin-top:20px; text-align:center;">
                    <button class="gm-login-btn" @click="becomeGm">ç®¡ç†é ˜åŸŸã¸ (GMãƒ­ã‚°ã‚¤ãƒ³)</button>
                </div>
            </div>
        </div>

        <!-- GMãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ« -->
        <div v-if="showGmPasswordModal" class="modal-overlay" @click.self="showGmPasswordModal = false">
            <div class="modal-content">
                <button class="close-btn" @click="showGmPasswordModal = false">Ã—</button>
                <h3
                    style="color:var(--text-main); margin-bottom:15px; text-align:center; border-bottom:1px solid var(--accent-gold); padding-bottom:10px;">
                    æ”¯é…è€…ã®åˆè¨€è‘‰</h3>
                <p style="font-size:0.9em; color:#666; margin-bottom:15px;">ç®¡ç†é ˜åŸŸã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å”±ãˆã‚ˆã€‚</p>
                <form @submit.prevent="submitGmLogin">
                    <input type="password" v-model="gmPasswordInput" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›..."
                        style="margin-bottom:20px;" autocomplete="off">
                    <button type="submit" class="primary">èªè¨¼</button>
                </form>
            </div>
        </div>

        <!-- ã‚¨ãƒ©ãƒ¼è¡¨ç¤º -->
        <div v-if="errorMessage" class="error-box">âš ï¸ {{ errorMessage }}</div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚¨ãƒªã‚¢ -->
        <main>
            <div v-if="loading" style="text-align:center; padding-top:50px;">
                <p style="color:var(--accent-gold);">é‹å‘½ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
            </div>

            <!-- ã‚¿ãƒ–: GMã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒšãƒ¼ã‚¸ (GMå°‚ç”¨) -->
            <div v-else-if="activeTab === 'gm'">
                <div class="config-panel" style="text-align:left;">
                    <h2 style="color:var(--accent-gold); margin-bottom:15px; text-align:center;">æ”¯é…è€… (GM) åˆ¶å¾¡ç›¤</h2>

                    <h3 style="color:var(--accent-gold); border-bottom:1px solid #555; margin-bottom:10px;">å½¹è·ã®é…åˆ†</h3>
                    <div v-for="(count, role) in roleCounts" :key="role"
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; padding-bottom: 2px; border-bottom: 1px dashed #333;">
                        <span :style="{color: getRoleColor(role)}">{{ roleDefinitions[role].label }}</span>
                        <div>
                            <button class="sm-btn" @click="adjustRole(role, -1)">-</button>
                            <span style="display:inline-block; width: 25px; text-align: center;">{{ count }}</span>
                            <button class="sm-btn" @click="adjustRole(role, 1)">+</button>
                        </div>
                    </div>
                    <div class="text-center" style="margin-top: 10px; font-weight: bold;">
                        <span :style="{ color: configStatusColor }">
                            è¨­å®š: {{ totalConfiguredRoles }} / å‚åŠ : {{ playerCount }}
                        </span>
                    </div>
                    <div v-if="roleCounts.WEREWOLF < 1" class="text-center" style="color: #ff5252; font-size: 0.8em;">
                        â€»äººç‹¼ãŒå¿…è¦</div>

                    <h3
                        style="color:var(--accent-gold); border-bottom:1px solid #555; margin-bottom:10px; margin-top:20px;">
                        è©³ç´°ãƒ«ãƒ¼ãƒ«</h3>
                    <div class="toggle-row">
                        <span class="toggle-label">ğŸ›¡ï¸ é¨å£«è‡ªè¡›</span>
                        <label class="toggle-switch"><input type="checkbox" v-model="gameConfig.knightSelfGuard"><span
                                class="slider"></span></label>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label">ğŸ”„ é€£ç¶šã‚¬ãƒ¼ãƒ‰</span>
                        <label class="toggle-switch"><input type="checkbox"
                                v-model="gameConfig.knightContinuousGuard"><span class="slider"></span></label>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label">ğŸ‘ï¸ ç‹¼ã®ç‹‚äººè¦–èª</span>
                        <label class="toggle-switch"><input type="checkbox" v-model="gameConfig.wolfKnowsMadman"><span
                                class="slider"></span></label>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label">ğŸ“¢ éœŠåª’çµæœå…¬é–‹</span>
                        <label class="toggle-switch"><input type="checkbox"
                                v-model="gameConfig.publicMediumResult"><span class="slider"></span></label>
                    </div>

                    <div style="margin-top:20px; border-top:1px solid #555; padding-top:10px;">
                        <h4 style="margin-bottom:10px;">é€²è¡Œåˆ¶å¾¡</h4>
                        <button v-if="state.phase === 'LOBBY'" class="primary" @click="startGame"
                            :disabled="!isConfigValid" style="width:100%; margin-bottom:10px;">å„€å¼é–‹å§‹</button>
                        <button v-if="state.phase === 'DAY'" @click="forceEndDay"
                            style="width:100%; margin-bottom:10px; background:#444;">è­°è«–ã‚’æ‰“ã¡åˆ‡ã‚Šã€æŠ•ç¥¨ã¸</button>
                        <button @click="resetGame" style="background:#d32f2f; color:white; border:none;">ä¸–ç•Œã‚’ç ´æ£„
                            (ãƒªã‚»ãƒƒãƒˆ)</button>
                    </div>
                </div>
            </div>

            <!-- ã‚¿ãƒ–1: é‹å‘½ (ãƒ­ãƒ“ãƒ¼ & ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆ) -->
            <div v-else-if="activeTab === 'players'">
                <div v-if="state.phase === 'LOBBY'" style="text-align:center;">
                    <h2 style="color:var(--accent-gold); margin-bottom:20px;">The Grimoire</h2>
                    <div v-if="!joined">
                        <input v-model="inputName" placeholder="æ±ã®åã‚’åˆ»ã‚" maxlength="10">
                        <button class="primary" @click="joinGame" :disabled="!inputName">å¥‘ç´„ï¼ˆå‚åŠ ï¼‰</button>
                    </div>
                    <div v-else>
                        <p>å¥‘ç´„å®Œäº†ã€‚é–‹å®´ã‚’å¾…ãŸã‚Œã‚ˆã€‚</p>
                    </div>
                    <div style="margin-top:20px; font-size:0.8em; color:#888;">
                        <div v-if="!isHost">
                            æ”¯é…è€…(GM)ãŒå„€å¼ã‚’æº–å‚™ä¸­...<br>
                            <span v-if="!state.host_uid"
                                style="color:var(--accent-gold)">â€»GMä¸åœ¨ã€‚å³ä¸Šã®æœ¬ã‚¢ã‚¤ã‚³ãƒ³ã‹ã‚‰ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚</span>
                        </div>
                        <div v-else>
                            <p style="color:var(--accent-gold);">ã‚ãªãŸã¯æ”¯é…è€…ã§ã™ã€‚<br>ã€Œæ”¯é…ã€ã‚¿ãƒ–ã‹ã‚‰è¨­å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚</p>
                        </div>
                    </div>
                </div>

                <div v-else>
                    <div v-for="p in state.players" :key="p.uid" class="player-list-item"
                        :class="{ dead: !p.is_alive }">
                        <div style="flex:1;">
                            <div>
                                <strong style="font-size:1.1em;">{{ p.name }}</strong>
                                <span v-if="p.uid === state.host_uid" class="host-badge">GM</span>
                                <span v-if="p.uid === myUid"
                                    style="color:var(--role-guard); font-size:0.8em; border:1px solid var(--role-guard); padding:0 3px; margin-left:5px;">YOU</span>
                                <span v-if="getVisualInfo(p.uid)" class="vis-badge"
                                    :style="{color: getVisualInfo(p.uid).color}">{{ getVisualInfo(p.uid).label }}</span>
                            </div>
                            <div v-if="getActionLog(p.uid)">
                                <span v-for="res in getActionLog(p.uid)" class="action-result"
                                    :class="{ 'result-danger': res.includes('â—')||res.includes('è¥²æ’ƒ')||res.includes('å‘ªæ®º'), 'result-safe': res.includes('â—‹'), 'result-fox': res.includes('ğŸ¦Š') }">{{
                                    res }}</span>
                            </div>
                        </div>
                        <div style="text-align:right; min-width:60px;">
                            <span v-if="!p.is_alive">ğŸ’€ æ­»äº¡</span>
                            <span v-else style="color:var(--role-guard)">ç”Ÿå­˜</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ã‚¿ãƒ–2: å„€å¼ (ã‚¢ã‚¯ã‚·ãƒ§ãƒ³) -->
            <div v-else-if="activeTab === 'action'">
                <div class="tarot-card" @click="showRole = !showRole">
                    <div v-if="!showRole">
                        <div style="font-size:3em; margin-bottom:10px;">ğŸƒ</div>
                        <p>ã‚¿ãƒƒãƒ—ã—ã¦é‹å‘½ï¼ˆå½¹è·ï¼‰ã‚’ç¢ºèª</p>
                    </div>
                    <div v-else>
                        <div class="tarot-title" :style="{color: getRoleColor(myRole)}">{{ myRoleLabel }}</div>
                        <div class="tarot-desc">{{ roleDefinitions[myRole].desc }}</div>
                        <div
                            style="font-size:0.7em; margin-top:10px; color:#555; border-top:1px dashed #aaa; padding-top:5px;">
                            (ã‚¿ãƒƒãƒ—ã§ä¼ã›ã‚‹)<br>
                            <span v-if="myRole==='KNIGHT'">è‡ªè¡›: {{ gameConfig.knightSelfGuard ? 'â—‹' : 'Ã—' }} / é€£ç¶š: {{
                                gameConfig.knightContinuousGuard ? 'â—‹' : 'Ã—' }}</span>
                        </div>
                    </div>
                </div>

                <div v-if="state.phase !== 'LOBBY' && !state.winner_team && myPlayer?.is_alive">
                    <h3 style="color:var(--accent-gold); margin-bottom:15px; text-align:center;">{{ state.phase ===
                        'NIGHT' ? 'æ·±å¤œã®å„€å¼' : (state.phase === 'VOTE' ? 'å‡¦åˆ‘æŠ•ç¥¨' : 'è­°è«–ã®æ™‚é–“') }}</h3>
                    <div v-if="hasActionDone"
                        style="text-align:center; padding:20px; border:1px solid var(--role-guard); color:var(--role-guard); background:rgba(0,100,0,0.1);">
                        é¸æŠã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚<br>æ™‚ãŒæº€ã¡ã‚‹ã®ã‚’å¾…ã¡ãªã•ã„ã€‚</div>
                    <div v-else>
                        <div v-if="state.phase === 'VOTE' || (state.phase === 'NIGHT' && !isNoActionRole)">
                            <p style="margin-bottom:10px; font-size:0.9em; color:#ccc; text-align:center;">{{
                                nightActionMessage || 'å¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„' }}</p>
                            <div v-for="p in actionTargets" :key="p.uid" class="spotlight-target"
                                :class="{ selected: targetUid === p.uid }">
                                <button class="target-btn" :class="{ active: targetUid === p.uid }"
                                    @click="targetUid = p.uid">{{ p.name }}</button>
                            </div>
                            <button class="primary" @click="submitAction" :disabled="!targetUid"
                                style="margin-top:20px; font-weight:bold;">æ±ºå®šã™ã‚‹</button>
                        </div>
                        <div v-else-if="state.phase === 'NIGHT' && isNoActionRole">
                            <p style="text-align:center; margin-bottom:20px;">ã‚ãªãŸã«ã¯å¤œã«è¡Œä½¿ã§ãã‚‹åŠ›ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
                            <button @click="submitAction">çœ ã‚Šã«ã¤ã</button>
                        </div>
                    </div>
                </div>

                <div v-if="!state.winner_team && !myPlayer?.is_alive && state.phase !== 'LOBBY'"
                    style="text-align:center; padding-top:20px; color:#777;">
                    <h3>ğŸ’€ ã‚ãªãŸã¯æ­»äº¡ã—ã¾ã—ãŸ</h3>
                    <p>éœŠç•Œã‹ã‚‰çµæœ«ã‚’è¦‹å±Šã‘ã¾ã—ã‚‡ã†</p>
                </div>

                <div v-if="state.winner_team"
                    style="text-align:center; padding:30px; border:2px solid var(--accent-gold); background:rgba(0,0,0,0.5);">
                    <h2 style="color:var(--accent-gold); margin-bottom:20px;">{{ state.winner_team === 'VILLAGERS' ?
                        'å¸‚æ°‘é™£å–¶' : state.winner_team === 'WEREWOLVES' ? 'äººç‹¼é™£å–¶' : 'å¦–ç‹é™£å–¶' }} å‹åˆ©</h2>
                </div>
            </div>

            <!-- ã‚¿ãƒ–3: å¹´ä»£è¨˜ (ãƒ­ã‚°) -->
            <div v-else-if="activeTab === 'logs'">
                <div v-for="(log, k) in logs" :key="k" class="story-card"
                    :class="{ death: log.message.includes('å‡¦åˆ‘') || log.message.includes('ç„¡æƒ¨') || log.message.includes('é“é€£ã‚Œ') }">
                    <span class="story-time">{{ formatLogTime(log) }}</span>
                    <span class="story-text">{{ log.message }}</span>
                </div>
                <div ref="logContainer"></div>
            </div>
        </main>

        <!-- ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->

    </div>

    <script type="module">
        import { createApp, reactive, computed, ref, watch, onMounted, nextTick } from 'vue';
        import { initializeApp } from 'firebase/app';
        import { getDatabase, ref as dbRef, set, update, onValue, push, serverTimestamp, remove } from 'firebase/database';

        // â–¼â–¼â–¼ Firebase Config (ã“ã“ã«è²¼ã‚Šä»˜ã‘) â–¼â–¼â–¼
        const firebaseConfig = {
            apiKey: "AIzaSyCMtk68RhSTxc3Z50RNDo4pdZqJV07NKlk",
            authDomain: "jinro-game-e0a88.firebaseapp.com",
            databaseURL: "https://jinro-game-e0a88-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "jinro-game-e0a88",
            storageBucket: "jinro-game-e0a88.firebasestorage.app",
            messagingSenderId: "469285329354",
            appId: "1:469285329354:web:b5a14b8fb5e0bc229c1733",
            measurementId: "G-KKZS80GP12"
        };
        // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

        const roleDefinitions = {
            VILLAGER: { label: 'å¸‚æ°‘', team: 'å¸‚æ°‘é™£å–¶', desc: 'èƒ½åŠ›ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è­°è«–ã¨æ¨ç†ã§äººç‹¼ã‚’è¿½ã„è©°ã‚ã¾ã—ã‚‡ã†ã€‚' },
            WEREWOLF: { label: 'äººç‹¼', team: 'äººç‹¼é™£å–¶', desc: 'æ¯æ™©ã€è¥²æ’ƒå¯¾è±¡ã‚’1äººé¸ã³ã¾ã™ã€‚ç¥¨ãŒå‰²ã‚ŒãŸå ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®šã•ã‚Œã¾ã™ã€‚' },
            SEER: { label: 'å ã„å¸«', team: 'å¸‚æ°‘é™£å–¶', desc: 'æ¯æ™©ã€1äººã®æ­£ä½“(äººç‹¼ã‹å¦ã‹)ã‚’å ã„ã¾ã™ã€‚å¦–ç‹ã¯å ã£ã¦ã‚‚æ­»ã«ã¾ã›ã‚“ãŒæ­£ä½“ã¯åˆ†ã‹ã‚Šã¾ã™ã€‚' },
            KNIGHT: { label: 'é¨å£«', team: 'å¸‚æ°‘é™£å–¶', desc: 'æ¯æ™©ã€1äººã‚’äººç‹¼ã®è¥²æ’ƒã‹ã‚‰å®ˆã‚Šã¾ã™ã€‚è‡ªåˆ†ã‚’å®ˆã‚Œã‚‹ã‹ã¯ãƒ«ãƒ¼ãƒ«æ¬¡ç¬¬ã§ã™ã€‚' },
            MADMAN: { label: 'ç‹‚äºº', team: 'äººç‹¼é™£å–¶', desc: 'äººé–“ã§ã™ãŒäººç‹¼ã«åŠ æ‹…ã—ã¾ã™ã€‚èƒ½åŠ›ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å˜˜ã‚’ã¤ã„ã¦å ´ã‚’æ··ä¹±ã•ã›ã¾ã—ã‚‡ã†ã€‚' },
            FANATIC: { label: 'ç‹‚ä¿¡è€…', team: 'äººç‹¼é™£å–¶', desc: 'äººç‹¼ãŒèª°ã‹åˆ†ã‹ã£ã¦ã„ã‚‹ç‹‚äººã§ã™ã€‚èƒ½åŠ›ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚' },
            MEDIUM: { label: 'éœŠåª’å¸«', team: 'å¸‚æ°‘é™£å–¶', desc: 'æ¯æ™©ã€å‰æ—¥ã«å‡¦åˆ‘ã•ã‚ŒãŸäººãŒã€Œäººç‹¼ã€ã ã£ãŸã‹ã©ã†ã‹ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚' },
            FOX: { label: 'å¦–ç‹', team: 'ç‹é™£å–¶', desc: 'ç¬¬3é™£å–¶ã€‚å ã‚ã‚Œã‚‹ã¨æ­£ä½“ãŒãƒãƒ¬ã¾ã™ãŒæ­»ã«ã¾ã›ã‚“ã€‚è¥²æ’ƒã‚‚ç„¡åŠ¹ã€‚æœ€å¾Œã¾ã§ç”Ÿãæ®‹ã‚Œã°å‹åˆ©ã€‚' },
            IMMORALIST: { label: 'èƒŒå¾³è€…', team: 'ç‹é™£å–¶', desc: 'å¦–ç‹ãŒèª°ã‹åˆ†ã‹ã‚Šã¾ã™ã€‚å¦–ç‹ãŒæ­»ã¬ã¨å¾Œã‚’è¿½ã£ã¦æ­»ã«ã¾ã™ã€‚' },
            CAT: { label: 'çŒ«åˆ', team: 'å¸‚æ°‘é™£å–¶', desc: 'å‡¦åˆ‘ã•ã‚Œã‚‹ã¨ãƒ©ãƒ³ãƒ€ãƒ ãª1äººã‚’ã€è¥²æ’ƒã•ã‚Œã‚‹ã¨çŠ¯äººã®äººç‹¼ã‚’é“é€£ã‚Œã«ã—ã¾ã™ã€‚' },
            BAKER: { label: 'ãƒ‘ãƒ³å±‹', team: 'å¸‚æ°‘é™£å–¶', desc: 'æ¯æœãƒ‘ãƒ³ã‚’ç„¼ãã¾ã™ã€‚ç”Ÿãã¦ã„ã‚‹ã“ã¨ãŒçš†ã«ä¼ã‚ã‚Šã¾ã™ã€‚' }
        };

        createApp({
            setup() {
                // â–¼â–¼â–¼ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š â–¼â–¼â–¼
                const GM_PASSWORD = 'admin';
                // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

                // UI State
                const activeTab = ref('players');
                const roomId = 'room_01';
                const loading = ref(true);
                const isSubmitting = ref(false);
                const errorMessage = ref('');
                const myUid = ref(localStorage.getItem('jinro_uid') || generateUuid());
                localStorage.setItem('jinro_uid', myUid.value);

                const inputName = ref('');
                const joined = ref(false);
                const showRole = ref(false);
                const showRoleList = ref(false);
                const targetUid = ref('');
                const timeLeft = ref(0);
                const logContainer = ref(null);
                const showGmPasswordModal = ref(false);
                const gmPasswordInput = ref('');
                const processingAction = ref(false); // é‡è¤‡å‡¦ç†é˜²æ­¢ç”¨ãƒ­ãƒƒã‚¯


                const state = reactive({
                    phase: 'LOBBY', turn_count: 1, timer_end_at: 0, host_uid: '', winner_team: null,
                    players: {}, actions: {}, executions: {}
                });

                // Rules & Data
                const gameConfig = reactive({
                    knightSelfGuard: false, knightContinuousGuard: false,
                    wolfKnowsMadman: false, publicMediumResult: false
                });
                const privateData = reactive({});
                const privateDataAll = reactive({});
                const logs = reactive({});
                const roleCounts = reactive({
                    WEREWOLF: 1, SEER: 1, KNIGHT: 1, MADMAN: 0, FANATIC: 0,
                    MEDIUM: 0, FOX: 0, IMMORALIST: 0, CAT: 0, BAKER: 0, VILLAGER: 1
                });

                // Firebase Init
                let db;
                try {
                    if (firebaseConfig.apiKey.includes("ã“ã“ã«")) throw new Error("API Keyæœªè¨­å®š: HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ã¦è¨­å®šã‚’æ›¸ãæ›ãˆã¦ãã ã•ã„");
                    const app = initializeApp(firebaseConfig);
                    db = getDatabase(app);
                } catch (e) {
                    errorMessage.value = e.message;
                    loading.value = false;
                }

                // Computed
                const myPlayer = computed(() => state.players?.[myUid.value]);
                const isHost = computed(() => state.host_uid === myUid.value);
                const playerCount = computed(() => Object.keys(state.players || {}).length);
                const myRole = computed(() => privateData[myUid.value]?.role || 'VILLAGER');
                const myRoleLabel = computed(() => roleDefinitions[myRole.value]?.label || '???');

                const phaseLabel = computed(() => {
                    const m = { LOBBY: 'å¾…åˆå®¤', NIGHT: 'æ·±å¤œ', DAY: 'æ˜¼', VOTE: 'å¯©åˆ¤' };
                    return m[state.phase] || state.phase;
                });

                const getRoleColor = (role) => {
                    const c = {
                        WEREWOLF: 'var(--role-wolf)', SEER: 'var(--role-seer)', KNIGHT: 'var(--role-guard)',
                        MADMAN: 'var(--role-madman)', FANATIC: 'var(--role-fanatic)',
                        MEDIUM: 'var(--role-medium)', FOX: 'var(--role-fox)', IMMORALIST: 'var(--role-immoral)',
                        CAT: 'var(--role-cat)', BAKER: 'var(--role-baker)'
                    };
                    return c[role] || 'var(--text-main)';
                };
                const roleColor = computed(() => getRoleColor(myRole.value));
                const roleStyle = computed(() => ({ borderColor: showRole.value ? roleColor.value : '#555' }));

                const actionTargets = computed(() => {
                    const living = Object.values(state.players || {}).filter(p => p.is_alive);
                    const otherLiving = living.filter(p => p.uid !== myUid.value);

                    if (state.phase === 'NIGHT' && myRole.value === 'KNIGHT') {
                        let targets = gameConfig.knightSelfGuard ? living : otherLiving;
                        if (!gameConfig.knightContinuousGuard && state.turn_count > 1) {
                            const lastTurn = state.actions?.[`turn_${state.turn_count - 1}`];
                            const lastGuarded = lastTurn?.night?.knight_action?.[myUid.value];
                            if (lastGuarded) targets = targets.filter(p => p.uid !== lastGuarded);
                        }
                        return targets;
                    }
                    return otherLiving;
                });

                const isNoActionRole = computed(() => ['VILLAGER', 'MADMAN', 'MEDIUM', 'FOX', 'CAT', 'BAKER', 'FANATIC', 'IMMORALIST'].includes(myRole.value));

                const nightActionMessage = computed(() => {
                    if (myRole.value === 'WEREWOLF') return 'ç‰™ã‚’å‰¥ãå¯¾è±¡ã‚’é¸ã¹';
                    if (myRole.value === 'SEER') return 'çœŸå®Ÿã‚’æš´ãå¯¾è±¡ã‚’é¸ã¹';
                    if (myRole.value === 'KNIGHT') return 'å®ˆè­·ã™ã‚‹å¯¾è±¡ã‚’é¸ã¹';
                    return '';
                });

                const hasActionDone = computed(() => {
                    const acts = state.actions?.[`turn_${state.turn_count}`]?.[state.phase === 'VOTE' ? 'day' : 'night'] || {};
                    if (state.phase === 'VOTE') return !!acts.votes?.[myUid.value];
                    if (state.phase === 'NIGHT') {
                        if (isNoActionRole.value) return !!acts.sleep?.[myUid.value];
                        if (myRole.value === 'WEREWOLF') return !!acts.wolf_votes?.[myUid.value];
                        if (myRole.value === 'SEER') return !!acts.seer_action?.[myUid.value];
                        if (myRole.value === 'KNIGHT') return !!acts.knight_action?.[myUid.value];
                    }
                    return false;
                });

                const totalConfiguredRoles = computed(() => Object.values(roleCounts).reduce((a, b) => a + b, 0));
                const isConfigValid = computed(() => totalConfiguredRoles.value === playerCount.value && playerCount.value >= 4 && roleCounts.WEREWOLF >= 1);
                const configStatusColor = computed(() => isConfigValid.value ? '#69f0ae' : '#ff5252');

                const getActionLog = (targetUid) => {
                    if (targetUid === myUid.value) return null;
                    const results = [];
                    for (let i = 1; i <= state.turn_count; i++) {
                        const turnData = state.actions?.[`turn_${i}`];
                        if (myRole.value === 'SEER') {
                            if (turnData?.night?.seer_action?.[myUid.value] === targetUid) {
                                const realRole = privateDataAll[targetUid]?.role;
                                let resText = (realRole === 'FOX') ? 'ğŸ¦Šå¦–ç‹' : (realRole === 'WEREWOLF' ? 'â—äººç‹¼' : 'â—‹äººé–“');
                                results.push(`Day${i}å :${resText}`);
                            }
                        }
                        if (myRole.value === 'MEDIUM') {
                            if (state.executions?.[`turn_${i}`] === targetUid) {
                                const realRole = privateDataAll[targetUid]?.role;
                                results.push(`Day${i}éœŠ:${realRole === 'WEREWOLF' ? 'â—äººç‹¼' : 'â—‹äººé–“'}`);
                            }
                        }
                        if (myRole.value === 'WEREWOLF') {
                            if (turnData?.night?.wolf_votes?.[myUid.value] === targetUid) results.push(`Day${i}è¥²æ’ƒ`);
                        }
                    }
                    return results.length > 0 ? results : null;
                };

                const getVisualInfo = (targetUid) => {
                    if (targetUid === myUid.value) return null;
                    const targetRole = privateDataAll[targetUid]?.role;
                    if (!targetRole) return null;
                    if (myRole.value === 'FANATIC' && targetRole === 'WEREWOLF') return { label: 'ğŸºå‘³æ–¹', color: 'var(--role-wolf)' };
                    if (myRole.value === 'IMMORALIST' && targetRole === 'FOX') return { label: 'ğŸ¦Šå´‡æ‹', color: 'var(--role-fox)' };
                    if (myRole.value === 'WEREWOLF' && targetRole === 'WEREWOLF') return { label: 'ğŸºå‘³æ–¹', color: 'var(--role-wolf)' };
                    if (gameConfig.wolfKnowsMadman && myRole.value === 'WEREWOLF' && targetRole === 'MADMAN') return { label: 'ğŸ¤ªç‹‚äºº', color: 'var(--role-madman)' };
                    return null;
                };

                // --- Sync & Watch ---
                onMounted(() => {
                    if (!db) return;
                    const roomRef = dbRef(db, `room/${roomId}`);
                    onValue(roomRef, (snapshot) => {
                        loading.value = false;
                        const data = snapshot.val();
                        if (data) {
                            if (data.state) Object.assign(state, data.state);
                            if (data.config) Object.assign(gameConfig, data.config);
                            state.players = data.players || {};
                            state.actions = data.actions || {};
                            state.executions = data.executions || {};
                            if (data.logs) {
                                Object.keys(logs).forEach(k => delete logs[k]);
                                Object.assign(logs, data.logs);
                                scrollToBottom();
                            }
                            if (state.players[myUid.value]) joined.value = true;
                            // è‡ªå‹•ãƒ›ã‚¹ãƒˆä»˜ä¸ãƒ­ã‚¸ãƒƒã‚¯ã‚’å‰Šé™¤ (GMæ©Ÿèƒ½å®Ÿè£…ã®ãŸã‚)
                            // if (!state.host_uid && joined.value) update(dbRef(db, `room/${roomId}/state`), { host_uid: myUid.value });

                            if (activeTab.value === 'players' && state.phase !== 'LOBBY') activeTab.value = 'action';
                            if (state.winner_team) activeTab.value = 'action';
                        } else {
                            state.phase = 'LOBBY';
                            joined.value = false;
                        }
                    });
                    onValue(dbRef(db, `room/${roomId}/private_data`), (s) => {
                        Object.assign(privateDataAll, s.val() || {});
                        if (privateDataAll[myUid.value]) privateData[myUid.value] = privateDataAll[myUid.value];
                    });
                });

                watch(gameConfig, (newVal) => { if (isHost.value) update(dbRef(db, `room/${roomId}/config`), newVal); });

                // --- Methods ---
                function generateUuid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => (Math.random() * 16 | 0).toString(16)); }
                const formatTime = (ts) => ts ? new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
                const formatLogTime = (log) => {
                    if (log.gameTime) {
                        const { phase, turn } = log.gameTime;
                        if (phase === 'LOBBY') return 'å¾…åˆå®¤';
                        if (phase === 'NIGHT') return `ç¬¬${turn}å¤œ`;
                        if (phase === 'DAY') return `${turn}æ—¥ç›® æ˜¼`;
                        if (phase === 'VOTE') return `${turn}æ—¥ç›® å¯©åˆ¤`;
                        return `${turn}æ—¥ç›®`;
                    }
                    return formatTime(log.timestamp);
                };
                const scrollToBottom = () => nextTick(() => { if (logContainer.value) logContainer.value.scrollIntoView({ behavior: "smooth", block: "end" }); });
                const joinGame = async () => await set(dbRef(db, `room/${roomId}/players/${myUid.value}`), { uid: myUid.value, name: inputName.value, is_alive: true });
                const toggleRole = () => showRole.value = !showRole.value;
                const adjustRole = (role, delta) => { const newVal = roleCounts[role] + delta; if (newVal >= 0) roleCounts[role] = newVal; };
                const pushLog = (msg) => push(dbRef(db, `room/${roomId}/logs`), {
                    message: msg,
                    timestamp: serverTimestamp(),
                    gameTime: { phase: state.phase, turn: state.turn_count }
                });

                // GM Login Functions (Revised - Optimistic Update)
                const becomeGm = () => {
                    showRoleList.value = false;
                    showGmPasswordModal.value = true;
                    gmPasswordInput.value = '';
                };

                const submitGmLogin = async () => {
                    console.log(`[GM Login] Input: '${gmPasswordInput.value}' vs Expected: '${GM_PASSWORD}'`);
                    if (gmPasswordInput.value.trim() === GM_PASSWORD) {
                        try {
                            // æ¥½è¦³çš„UIæ›´æ–°: ã¾ãšç”»é¢ã‚’å¤‰ãˆã‚‹
                            showGmPasswordModal.value = false;
                            state.host_uid = myUid.value; // ãƒ­ãƒ¼ã‚«ãƒ«ã§å³åº§ã«GMæ¨©é™ä»˜ä¸
                            activeTab.value = 'gm'; // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ

                            // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§DBæ›´æ–°
                            console.log('[GM Login] Granting GM rights...');
                            await update(dbRef(db, `room/${roomId}/state`), { host_uid: myUid.value });
                            console.log('[GM Login] DB Updated.');

                            alert('èªè¨¼æˆåŠŸ: æ”¯é…è€…æ¨©é™ã‚’å–å¾—ã—ã¾ã—ãŸã€‚');
                        } catch (e) {
                            console.error('[GM Login Error]', e);
                            alert('ã‚¨ãƒ©ãƒ¼: ' + e.message);
                        }
                    } else {
                        console.log("Password mismatch");
                        alert('è¨€è‘‰ãŒé•ã†ã‚ˆã†ã ...');
                    }
                };

                const startGame = async () => {
                    if (!isHost.value) return;
                    const uids = Object.keys(state.players);
                    const roles = [];
                    for (const [role, count] of Object.entries(roleCounts)) {
                        for (let i = 0; i < count; i++) roles.push(role);
                    }
                    if (roles.length !== uids.length) { alert('äººæ•°è¨­å®šã‚¨ãƒ©ãƒ¼'); return; }
                    for (let i = roles.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[roles[i], roles[j]] = [roles[j], roles[i]]; }

                    const pData = {};
                    uids.forEach((uid, i) => pData[uid] = { role: roles[i] });

                    await update(dbRef(db), {
                        [`room/${roomId}/private_data`]: pData,
                        [`room/${roomId}/state`]: { phase: 'NIGHT', turn_count: 1, winner_team: null, host_uid: myUid.value },
                        [`room/${roomId}/actions`]: null,
                        [`room/${roomId}/logs`]: null,
                        [`room/${roomId}/executions`]: null,
                        [`room/${roomId}/config`]: gameConfig
                    });
                    pushLog('ç‰©èªãŒå¹•ã‚’é–‹ã‘ã‚‹ã€‚ç¬¬ä¸€ã®å¤œã€‚');
                };

                const ROLE_ACTION_MAP = {
                    VOTE: { segment: 'day/votes', required: false, allowSkip: true },
                    SLEEP: { segment: 'night/sleep', required: false, allowSkip: true },
                    WEREWOLF: { segment: 'night/wolf_votes', required: true, allowSkip: true },
                    SEER: { segment: 'night/seer_action', required: true, allowSkip: false },
                    KNIGHT: { segment: 'night/knight_action', required: true, allowSkip: false },
                };

                function safeErrorMessage(e) {
                    if (!e) return 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
                    if (e.message) return e.message;
                    try { return JSON.stringify(e); } catch { return String(e); }
                }

                const submitAction = async () => {
                    if (isSubmitting.value) return;

                    const base = `room/${roomId}/actions/turn_${state.turn_count}`;
                    let actionInfo = null;
                    let path = '';

                    // â–¼ ãƒ•ã‚§ãƒ¼ã‚ºåˆ¥ã«é€ä¿¡å…ˆæ±ºå®š
                    if (state.phase === 'VOTE') {
                        actionInfo = ROLE_ACTION_MAP.VOTE;
                        path = `${base}/${actionInfo.segment}/${myUid.value}`;
                    } else if (state.phase === 'NIGHT') {
                        if (isNoActionRole.value) {
                            actionInfo = ROLE_ACTION_MAP.SLEEP;
                            path = `${base}/${actionInfo.segment}/${myUid.value}`;
                        } else {
                            actionInfo = ROLE_ACTION_MAP[myRole.value];
                            if (actionInfo) {
                                path = `${base}/${actionInfo.segment}/${myUid.value}`;
                            }
                        }
                    }

                    // â–¼ ãƒ‘ã‚¹ãŒæ±ºã¾ã‚‰ãªã„ï¼ãƒã‚° or æœªå¯¾å¿œå½¹è·
                    if (!path) {
                        errorMessage.value = 'é€ä¿¡å…ˆãŒæ±ºå®šã§ãã¾ã›ã‚“ï¼ˆæœªå¯¾å¿œã®ãƒ•ã‚§ãƒ¼ã‚º/å½¹è·ï¼‰';
                        return;
                    }

                    // â–¼ è¡Œå‹•å¿…é ˆãªã®ã«æœªé¸æŠ â†’ ãƒ–ãƒ­ãƒƒã‚¯
                    const noTarget = !targetUid.value || targetUid.value === '';
                    if (actionInfo.required && noTarget && !actionInfo.allowSkip) {
                        showAlert('å¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                        return;
                    }

                    const valueToSend = noTarget
                        ? (actionInfo.allowSkip ? 'SKIP' : '')
                        : targetUid.value;

                    if (valueToSend === '') {
                        errorMessage.value = 'ç„¡åŠ¹ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ã€‚';
                        return;
                    }

                    // â–¼ é€ä¿¡é–‹å§‹
                    isSubmitting.value = true;
                    errorMessage.value = '';

                    try {
                        await set(dbRef(db, path), valueToSend);

                        // å¿…è¦ãªã‚‰è»½ã„é€šçŸ¥ï¼ˆSEER ã®å ã„çµæœé€šçŸ¥ã¯ã“ã“ã§ã¯è¡Œã‚ãªã„ï¼‰
                        showAlert('é€ä¿¡ã—ã¾ã—ãŸã€‚');

                        // æˆåŠŸå¾Œãƒªã‚»ãƒƒãƒˆ
                        targetUid.value = '';
                    } catch (e) {
                        errorMessage.value = "é€ä¿¡ã‚¨ãƒ©ãƒ¼: " + safeErrorMessage(e);
                    } finally {
                        isSubmitting.value = false;
                    }
                };


                const forceEndDay = async () => {
                    if (!isHost.value) return;
                    await update(dbRef(db, `room/${roomId}/state`), { phase: 'VOTE', timer_end_at: 0 });
                    pushLog('è­°è«–çµ‚äº†ã€‚å¯©åˆ¤ã®æ™‚ã€‚');
                };

                const resetGame = async () => {
                    if (confirm('å…¨ã¦ã‚’ç™½ç´™ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ')) {
                        await remove(dbRef(db, `room/${roomId}`));
                        location.reload();
                    }
                };

                setInterval(() => {
                    if (state.timer_end_at && state.timer_end_at > 0) {
                        const diff = Math.floor((state.timer_end_at - Date.now()) / 1000);
                        timeLeft.value = diff > 0 ? diff : 0;
                        if (isHost.value && diff <= 0 && state.phase === 'DAY') forceEndDay();
                    }
                }, 1000);

                watch(() => state.actions, (newActions) => {
                    if (!isHost.value) return;
                    const currentTurn = state.actions?.[`turn_${state.turn_count}`];
                    const living = Object.values(state.players).filter(p => p.is_alive);
                    if (living.length === 0) return;
                    if (processingAction.value) return; // å‡¦ç†ä¸­ãªã‚‰ç„¡è¦–

                    if (state.phase === 'VOTE' && currentTurn?.day?.votes) {
                        if (Object.keys(currentTurn.day.votes).length >= living.length) resolveVote(currentTurn.day.votes, living);
                    }

                    if (state.phase === 'NIGHT' && currentTurn?.night) {
                        const acts = currentTurn.night;
                        const doneCount = Object.keys(acts.sleep || {}).length + Object.keys(acts.wolf_votes || {}).length + Object.keys(acts.seer_action || {}).length + Object.keys(acts.knight_action || {}).length;
                        if (doneCount >= living.length) resolveNight(acts);
                    }
                }, { deep: true });

                const resolveVote = async (votes, living) => {
                    processingAction.value = true;
                    try {
                        const counts = {};
                        Object.values(votes).forEach(t => counts[t] = (counts[t] || 0) + 1);
                        const max = Math.max(...Object.values(counts));
                        const candidates = Object.keys(counts).filter(k => counts[k] === max);
                        const executedId = candidates[Math.floor(Math.random() * candidates.length)];

                        await update(dbRef(db, `room/${roomId}/players/${executedId}`), { is_alive: false });
                        if (state.players[executedId]) state.players[executedId].is_alive = false; // Optimistic update
                        await set(dbRef(db, `room/${roomId}/executions/turn_${state.turn_count}`), executedId);
                        pushLog(`${state.players[executedId].name} ãŒå‡¦åˆ‘ã•ã‚ŒãŸã€‚`);

                        if (gameConfig.publicMediumResult) {
                            const r = privateDataAll[executedId]?.role;
                            const isWolf = r === 'WEREWOLF';
                            pushLog(`éœŠåª’çµæœ: å½¼å¥´ã¯ ${isWolf ? 'äººç‹¼' : 'äººé–“'} ã§ã‚ã£ãŸã€‚`);
                        }

                        if (privateDataAll[executedId]?.role === 'CAT') {
                            const others = living.filter(p => p.uid !== executedId);
                            if (others.length > 0) {
                                const companion = others[Math.floor(Math.random() * others.length)];
                                await update(dbRef(db, `room/${roomId}/players/${companion.uid}`), { is_alive: false });
                                if (state.players[companion.uid]) state.players[companion.uid].is_alive = false; // Optimistic update
                                pushLog(`çŒ«åˆã®å‘ªã„ã«ã‚ˆã‚Šã€${companion.name} ãŒé“é€£ã‚Œã¨ãªã£ãŸã€‚`);
                            }
                        }
                        if (privateDataAll[executedId]?.role === 'FOX') await checkImmoralistDeath();

                        if (await checkWinCondition()) return;
                        await update(dbRef(db, `room/${roomId}/state`), { phase: 'NIGHT' });
                        pushLog('å¤œãŒè¨ªã‚Œã‚‹ã€‚');
                    } finally {
                        processingAction.value = false;
                    }
                };

                const resolveNight = async (nightActs) => {
                    processingAction.value = true;
                    try {
                        if (state.turn_count === 1) {
                            await nextDay('é™ã‹ãªæœã€‚æ˜¨æ™©ã®çŠ ç‰²è€…ã¯ã„ãªã„ã€‚');
                            return;
                        }
                        const wolfVotes = nightActs.wolf_votes || {};
                        const counts = {};
                        Object.values(wolfVotes).forEach(t => counts[t] = (counts[t] || 0) + 1);
                        let targetId = null;
                        const attackers = [];
                        if (Object.keys(counts).length > 0) {
                            const max = Math.max(...Object.values(counts));
                            const cands = Object.keys(counts).filter(k => counts[k] === max);
                            targetId = cands[Math.floor(Math.random() * cands.length)];
                            Object.entries(wolfVotes).forEach(([uid, target]) => { if (target === targetId) attackers.push(uid); });
                        }

                        const guardId = Object.values(nightActs.knight_action || {})[0];
                        const victims = [];

                        if (targetId && targetId !== guardId) {
                            if (privateDataAll[targetId]?.role !== 'FOX') {
                                victims.push(targetId);
                                if (privateDataAll[targetId]?.role === 'CAT' && attackers.length > 0) {
                                    const badWolf = attackers[Math.floor(Math.random() * attackers.length)];
                                    victims.push(badWolf);
                                }
                            }
                        }

                        const uniqueVictims = [...new Set(victims)];
                        for (const vid of uniqueVictims) {
                            await update(dbRef(db, `room/${roomId}/players/${vid}`), { is_alive: false });
                            if (state.players[vid]) state.players[vid].is_alive = false; // Optimistic update
                        }
                        let foxDied = uniqueVictims.some(vid => privateDataAll[vid]?.role === 'FOX');
                        if (foxDied) await checkImmoralistDeath(uniqueVictims);

                        let msg = 'é™ã‹ãªæœã€‚æ˜¨æ™©ã®çŠ ç‰²è€…ã¯ã„ãªã„ã€‚';
                        const deadNames = uniqueVictims.map(id => state.players[id].name);
                        if (uniqueVictims.length > 0) msg = `æœã€‚${deadNames.join('ã€')} ã®ç„¡æƒ¨ãªæ­»ä½“ãŒç™ºè¦‹ã•ã‚ŒãŸã€‚`;
                        else if (targetId && targetId === guardId) msg = 'æœã€‚é¨å£«ã®å®ˆè­·ã«ã‚ˆã‚Šã€çŠ ç‰²è€…ã¯å‡ºãªã‹ã£ãŸï¼';

                        if (await checkWinCondition()) return;
                        await nextDay(msg);
                    } finally {
                        processingAction.value = false;
                    }
                };

                const checkImmoralistDeath = async (excludeIds = []) => {
                    const living = Object.values(state.players).filter(p => p.is_alive && !excludeIds.includes(p.uid));
                    const immoralists = living.filter(p => privateDataAll[p.uid]?.role === 'IMMORALIST');
                    for (const p of immoralists) {
                        await update(dbRef(db, `room/${roomId}/players/${p.uid}`), { is_alive: false });
                        if (state.players[p.uid]) state.players[p.uid].is_alive = false; // Optimistic update
                        pushLog(`å¦–ç‹ã®å¾Œã‚’è¿½ã„ã€èƒŒå¾³è€… ${p.name} ãŒæœã¦ãŸã€‚`);
                    }
                };

                const nextDay = async (msg) => {
                    pushLog(msg);
                    const living = Object.values(state.players).filter(p => p.is_alive);
                    const bakerAlive = living.some(p => privateDataAll[p.uid]?.role === 'BAKER');
                    if (bakerAlive) pushLog('ğŸ ãƒ‘ãƒ³å±‹ãŒãƒ‘ãƒ³ã‚’ç„¼ã„ãŸã‚ˆã†ã ã€‚');
                    await update(dbRef(db), {
                        [`room/${roomId}/state/phase`]: 'DAY',
                        [`room/${roomId}/state/turn_count`]: state.turn_count + 1,
                        [`room/${roomId}/state/timer_end_at`]: Date.now() + 1000 * 60 * 3
                    });
                };

                const checkWinCondition = async () => {
                    if (!isHost.value || state.winner_team || state.phase === 'LOBBY') return false;
                    await new Promise(r => setTimeout(r, 500));
                    const living = Object.values(state.players).filter(p => p.is_alive);
                    if (living.length === 0) return false;
                    if (!living.every(p => privateDataAll[p.uid])) return false;

                    let wolves = 0, humans = 0, foxes = 0;
                    living.forEach(p => {
                        const r = privateDataAll[p.uid]?.role;
                        if (r === 'WEREWOLF') wolves++;
                        else if (r === 'FOX') foxes++;
                        else humans++;
                    });
                    let win = null;
                    if (wolves === 0) win = foxes > 0 ? 'FOX' : 'VILLAGERS';
                    else if (wolves >= humans + foxes) win = foxes > 0 ? 'FOX' : 'WEREWOLVES';

                    if (win) {
                        await set(dbRef(db, `room/${roomId}/state/winner_team`), win);
                        pushLog(`æ±ºç€ã€‚${win === 'FOX' ? 'å¦–ç‹' : (win === 'VILLAGERS' ? 'å¸‚æ°‘' : 'äººç‹¼')}é™£å–¶ã®å‹åˆ©ã€‚`);
                        return true;
                    }
                    return false;
                };

                return {
                    state, loading, errorMessage, roomId, inputName, joined, showRole, toggleRole,
                    myUid, myPlayer, isHost, playerCount, joinGame, startGame, resetGame,
                    phaseLabel, timeLeft, formatTime, myRole, myRoleLabel, roleDefinitions, roleStyle, roleColor,
                    actionTargets, isNoActionRole, hasActionDone, submitAction, targetUid, nightActionMessage, forceEndDay, logs, logContainer,
                    getActionLog, roleCounts, totalConfiguredRoles, isConfigValid, configStatusColor, adjustRole, getRoleColor,
                    getVisualInfo, showRoleList, gameConfig, activeTab, becomeGm, showGmPasswordModal, gmPasswordInput, submitGmLogin,
                    formatLogTime,

                };
            }
        }).mount('#app');
    </script>
</body>

</html>
